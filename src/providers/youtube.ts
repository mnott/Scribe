import type {
  ContentProvider,
  ExtractionOptions,
  ExtractionResult,
  ProviderCapabilities,
} from "../types.ts";
import {
  extractVideoId,
  transcribeVideo,
  type TranscriptSegment,
} from "../lib/youtube.ts";
import { ExtractionError } from "../lib/errors.ts";

export class YouTubeProvider implements ContentProvider {
  readonly name = "youtube";
  readonly description = "Transcribes YouTube videos by extracting captions/subtitles";

  canHandle(input: string): boolean {
    return extractVideoId(input) !== null;
  }

  capabilities(): ProviderCapabilities {
    return {
      formats: ["text", "srt", "json"],
      supportsLanguage: true,
      supportsTimestamps: true,
    };
  }

  async extract(input: string, options: ExtractionOptions = {}): Promise<ExtractionResult> {
    const { language = "en", format = "text", timestamps = false } = options;

    // Map OutputFormat to TranscriptFormat â€” markdown not supported, fall back to text
    const ytFormat = format === "markdown" ? "text" : format;

    // When timestamps requested with text format, fetch as JSON to get timing data
    const fetchFormat = ytFormat === "text" && timestamps ? "json" : ytFormat;

    try {
      const result = await transcribeVideo(input, { language, format: fetchFormat });

      const autoLabel = result.isAutoGenerated ? " (auto-generated)" : " (manual)";

      let content: string;
      if (ytFormat === "json") {
        content = JSON.stringify(result.transcript, null, 2);
      } else if (ytFormat === "text" && timestamps) {
        const segments = result.transcript as TranscriptSegment[];
        content = segments
          .map((s) => {
            const totalSec = Math.floor(s.startMs / 1000);
            const m = Math.floor(totalSec / 60);
            const sec = totalSec % 60;
            const ts = `[${String(m).padStart(2, "0")}:${String(sec).padStart(2, "0")}]`;
            return `${ts} ${s.text}`;
          })
          .join("\n");
      } else {
        content = result.transcript as string;
      }

      return {
        content,
        metadata: {
          title: `YouTube video ${result.videoId}`,
          source: `https://www.youtube.com/watch?v=${result.videoId}`,
          language: `${result.language}${autoLabel}`,
          format: ytFormat,
        },
        provider: this.name,
      };
    } catch (err) {
      if (err instanceof Error && err.name !== "ExtractionError") {
        throw new ExtractionError(`YouTube extraction failed: ${err.message}`, err);
      }
      throw err;
    }
  }
}
